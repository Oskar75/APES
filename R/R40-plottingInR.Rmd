---
output:
  html_document:
    keep_md: yes
    fig_width: 5
---
---
layout: page
title: Plotting in R
category: r
---

Contents

* Useful Links
* Simple standard plot
	* Scatterplot
		* Simple scatterplot
	 	* Scatterplot matrices
	 	* High Density Scatterplot
		* Three-dimensional scatterplot
    	* Line plots
    	* Bar plots
	 	* Simple Bar Plot
	 	* Stacked Bar Plot
	* Pie charts
	* Histograms
  		* Simple Histogram
	* Density plots
* Others
	* Box plots
		* Interpreting boxplots
		* Notched Boxplot
		* Violin Plot
		* Bag Plot
* Understanding graphics
	* Colors




Plotting in R
=== 

# Useful Links

•Wiki page with basic plotting examples:
http://en.wikibooks.org/wiki/R_Programming/Graphics

•The Quick-R page has more complete information about everytipe of plot:
http://www.statmethods.net/graphs/creating.html

•Derek Ogle's book chapter is a quick but clear introduction to plotting for Fisheries Analyses:
https://5c3dc6c1-a-62cb3a1a-s-sites.googlegroups.com/site/fishrfiles/home/ifswr-drafts/Plotting_IntroFishAnalysisR.pdf?attachauth=ANoY7cqgeZWxKf36OxjHT4us56VkfzalvamJF5QAhzOEcUN_16c3YC7jO-B9X9qMju9DKW_XoMziYJyXU-pMYeyf593KPjkYSb5_q897f6jBbXykDcGhAz9jX1VD1sZQN_D5DTlp2BZXta3KNuCLAnrtReRZ3zQ6olNjTIKXVR8TwEebBQIyE2Tt90ihWEqU37bSNcQqtvyooFVE8BgXNdD5MRFDyGI411rtUUqf_whDVv7MFZkj9hOGXeCQ3LsMCamTZ0KEi6Ua&attredirects=0

•List of graphic packages that are available and how they fit together:
http://mran.revolutionanalytics.com/taskview/info/?Graphics

•Paul Maurell's book, "R Graphics", is a resource that helps users to master the intricacies of R graphics:
https://www.stat.auckland.ac.nz/~paul/RGraphics/rgraphics.html

•How to change the font in R charts:
http://blog.revolutionanalytics.com/2012/09/how-to-use-your-favorite-fonts-in-r-charts.html

•About changing the background color in plots:
https://stat.ethz.ch/pipermail/r-help/2003-May/033971.html

•How to plot mathematical annotation:
http://vis.supstat.com/2013/04/mathematical-annotation-in-r/ and http://blog.revolutionanalytics.com/2013/04/math-symbols-in-r.html

•Some tips about how to improve R graphics:
http://blog.revolutionanalytics.com/2009/01/10-tips-for-making-your-r-graphics-look-their-best.html

•We can also find a R graphic's chapter in "An Introduction to R":
http://cran.r-project.org/doc/manuals/r-release/R-intro.html#Graphics


# Simple standard plots

The basic plotting command in R is the "plot()" function. Depending on which data type it is provided with, it will do different plots. 

## Scatter plot

The most basic plot that can be done with the plot() function is a scatter plot. This option will be chosen if you provide plot() with one or two vectors. If provided with one vector, plot will use this as the y-axis. If provided with two vectors, plot() will use the first as x-values, and the second vector as y-values. 

### Simple Scatterplot

We'll use the dataset Iris
```{r}
attach(iris) # remember to detach in the end 
head(iris)
```

To plot Sepal.Length against Petal.Length, use the following command

```{r}
plot(Petal.Length, Sepal.Length)
```
We can improve this plot by adding graphic options. The most basic options are provided in the help

```{r}
?plot
```
For example

```{r}
plot(Petal.Length, Sepal.Length, main="Simple Scatterplot",xlab="Petal Length ",ylab="Sepal Length " , 
     pch=22, col="red", bg="blue",cex=3, lwd=2)
```


Where:	
 * Petal.Length = x	   
 * Sepal.Length = y		 
 * main = Main title	
 * xlab = title for the x axis	
 * ylab = title for the y axis
 * pch = type of symbol	
 * col = color of pch	
 * bg = background color of pch (from 21 to 25)	  
 * lwd = size of pch	


It is possible to add **fitting lines**, that is, a line on a graph showing the general direction that a group of points seem to be heading.:   

1.	Regresion line, where y is dependent of x (y~x).
```{r}
abline(lm(Sepal.Length~Petal.Length), col="red")
```
2.	Lowess returns a list containing components x and y which give the coordinates of the smooth. 
```{r}		
lines(lowess(Petal.Length, Sepal.Length), col="blue")
```

By downloading the <b>car</b> package we can use more enhanced features

```{r}
library(car)
scatterplot(Sepal.Length~Petal.Length | Species, data=iris, boxplots= "x,y",
            xlab="Petal Length ",ylab="Sepal Length ",
            main="Enhanced Scatter Plot", labels=row.names(iris))
```

Where:
* `Sepal.Length~Petal.Length | Species` = the formula to plot by groups `(x ~ y | z)`. It could also be a formula of the type `x ~ y`.  
* `data` = dataframe   
* `boxplots` = boxplots for x and/or y   
* `main` = main title   
* `xlab` = title for the x axis	  
* `ylab` = title for the y axis   
* `labels` = labels for the points    


Other enhanced features include: boxplots, regresion lines, jitter factors, legend options, etc.


### Scatterplot Matrices

It is possible to assess the relationships between multiple variables simultaneously by using a Scatterplot Matrix. 
It is an ordered collection of bivariate graphs, making it easy to look at all pairwise correlations in one place.

The scatterplot matrices command is pairs()

```{r}
pairs(iris)

pairs(~Sepal.Length+Sepal.Width+Petal.Length+Petal.Width,data=iris,
      main="Simple Scatterplot Matrix")
```

Where:   
* `~Sepal.Length+Sepal.Width+Petal.Length+Petal.Width` = Numeric vectors that represent the variables in the plot  
* `data` = the data frame
* `main` = main title   

With the **lattice** package it is possible to condicion our matrix on a factor (tree specie in this case)

```{r}
library(lattice)
super.sym <- trellis.par.get("superpose.symbol")  
splom(~iris[1:4], groups = Species, data = iris,  
      superpanel, key = list(title = "Varieties of Iris",  
                 columns = 3,   
                 points = list(pch = super.sym$pch[1:3],  
                               col = super.sym$col[1:3]),  
                 text = list(c("Setosa", "Versicolor", "Virginica"))))  
```  

Where:   
•~iris[1:4] = the object we want to analyse (columns 1 to 4)  
•groups = which variable is going to be evaluated  
•data = dataframe   
•superpanel = function that sets up the splom display, by default as a scatterplot matrix   
•key = legend   
•text = labels for levels of the grouping variable   



We can also condicion our matrix on a factor with the <b>car</b> package.   
The advantage of this package is that we can include lowess and linear best fit lines,  boxplots, densities, or histograms in the principal diagonal, as well as rug plots in the margins of the cells.

```{r}
library(car)
scatterplot.matrix(~Sepal.Length+Sepal.Width+Petal.Length+Petal.Width|Species, data=iris,   
                   main="Three Species Options") 
```


With the <b>gclus</b> package we can rearrange the variables to represent those with higher correlations closer to the principal diagonal and to set up diferent colors depending of the correlation grade.  

```{r}
library(gclus)  
data <- iris[c(1,2,3,4)]    
data.corr <- abs(cor(data))  
data.color <- dmat.color(data.corr) 
# reorder variables so those with highest correlation  
# are closest to the diagonal  
data.order <- order.single(data.corr)   
cpairs(data, data.order, panel.colors=data.color, gap=.5,  
       main="Correlation Graph" )  
```
Where:   
•data = we get the data (columns 1,2,3,4 in this case)   
•data.corr = we get the correlations    
•data.color = get the colors depending of the correlation   
•data.order = to reorder the variables according to the correlation and proximity to the diagonal   
•cpairs = plotting the result     



### High Density Scatterplot

There are 2 options to plot whenever we are working with too many data points that overlap.  
The <b>hexbin</b> package creates a group of hexagonal cells and a count of points falling in each occupied cell. 
```{r}
library(hexbin)  
bin<-hexbin(Petal.Width ~ Petal.Length, xbins=100, xlab="Petal.Width",ylab="Petal.Length")  
plot(bin, main="Hexagonal Binning") 
```
Where:  
•xbins = number of hexagons across the x axis  


The other option is the <b>sunflowerplot</b> function.

```{r}
sunflowerplot(Petal.Width ~ Petal.Length, data = iris,  
              cex = .5, cex.fact = .8, size = .15,   
              xlab="Petal.Width",ylab="Petal.Length", main= "Sunflower Plot")  
```
Where:   
•cex = size of the center points  
•cex.fact = size of the center points where there are flower leaves   
•size = size of the flower leaves  


### Three-dimensional

we need the <b>scatterplot3d</b> package to represent 3D scatterplots.

```{r}
library(scatterplot3d)  
iris3d<-scatterplot3d(Sepal.Length,Sepal.Width,Petal.Length, pch=18, highlight.3d=TRUE,  
              type="h", main="3D Iris")  
reg.plane <- lm(Petal.Length ~ Sepal.Length+Sepal.Width)   
iris3d$plane3d(reg.plane)  
```
Where:   
•pch = type of symbol   
•highlight.3d = the points will are colored according to the y coordinates     
•type = "p" for points, "l" for lines, "h" for vertical lines   
•plane3d = we draw a regression plane


![3d scatterplot](https://raw.githubusercontent.com/biometry/APES/master/images/3D%20scatterplot.png)

It is possible to spin our 3d model with the mouse using the <b>rgl</b> package or the <b>Rcmdr</b> package.  

```{r}
library(rgl)   
plot3d(Sepal.Length,Sepal.Width,Petal.Length, col="blue", size=4)  
```

```{r}
library(Rcmdr)  
scatter3d(Sepal.Length,Sepal.Width,Petal.Length)  
```


## Line plots

we will represent the diferent <b>types of lines</b> in one plot with random x and y data:
```{r}
x <- c(1:5); y <- x 
par(pch=22, col="blue") 
par(mfrow=c(2,4)) 
opts = c("p","l","o","b","c","s","S","h") 
for(i in 1:length(opts)){ 
  heading = paste("type=",opts[i]) 
  plot(x, y, type="n", main=heading) 
  lines(x, y, type=opts[i])}
```   
Where:   
•mfrow = with this option we represent all the plots in the same page. To go back to only one plot per page, we write par(mfrow=c(1,1))    
* types
  * p = points  
  * l = lines  
  * o = points & lines overplotted  
  * b = points linked by lines  
  * c = intermittent lines  
  * s, S = stair steps  
  * h = vertical lines  
  * n = nothing   
* plot = we create a plot where we will add the lines  
* lines = lines to add to the created plot  


An example with our iris data:   
```{r}
# convert factor to numeric for convenience 
iris$Species <- as.numeric(iris$Species) 
ntrees <- max(iris$Species)

# get the range for the x and y axis 
xrange <- range(iris$Sepal.Width) 
yrange <- range(iris$Sepal.Length) 

# set up the plot 
plot(xrange, yrange, type="n", xlab="Sepal Width",
     ylab="Sepal Length " ) 
colors <- rainbow(ntrees) 

# add lines 
for (i in 1:ntrees) { 
  species <- subset(iris, Species==i) 
  lines(species$Sepal.Width,species$Sepal.Length, type="b", lwd=1.5,
        lty=1:ntrees, col=colors[i], pch=1:ntrees)} 

# add title and legend
title("Iris Sepals")
legend(xrange[1], yrange[2], 1:ntrees, cex=0.8, col=colors,
       pch=1:ntrees, lty=1:ntrees, title="Species")
```



## Bar plots

### Simple Bar Plot

```{r}
counts <- table(iris$Petal.Length)
barplot(counts, main="Iris Distribution", 
        xlab="Petal Length")
```

It is possible to plot the bars horizontal by adding horiz=TRUE to the code

![Simple Bar plot](https://raw.githubusercontent.com/biometry/APES/master/images/barplot.png)

### Stacked Bar Plot

If we want to represent different values in each bar

```{r}
counts <- table(iris$Species, iris$Petal.Length)  
barplot(counts, main="iris species distribution by petal leghts",
                    xlab="Petal Length",  col=c("darkblue","red", "green"),
                    legend = rownames(counts))
```

We can represent each value in a bar instead of stacked by adding beside=TRUE to the code


## Pie charts

Don't do them! Use Bar plots instead as it is easier to appreciate the differences between bars. But if you have to use them:

```{r}
#set up the variables
Spcs <- table(iris$Species) 
Spcs
lbls <- c("Setosa", "Versicolor", "Virginica")
# add percentages to the pie
pct <- round(Spcs/sum(Spcs)*100)
lbls <- paste(lbls, pct)
lbls <- paste(lbls,"%",sep="")
# plot the chart
pie(Spcs,labels = lbls,
main="Pie Chart of Countries")
```


With the <b>plotrix</b> package we can create 3d pie charts

## Histograms

Not recommended as its accuracy depends of the number of bins used

### Simple Histogram

```{r}
Petal<-iris$Petal.Length				
hist(Petal)		
```

```{r}
hist(Petal,freq=FALSE, breaks=15,col="green")		
```		
* freq = to show densities instead of frequencies		
* breaks = we can set up the number of bins		


We can add a <b>normal curve</b> to our histogram

```{r}
h<-hist(Petal, breaks=15, col="green", xlab="Petal Length", 		
        main="Histogram with Normal Curve") 		
xfit<-seq(min(Petal),max(Petal),length=40) 		
yfit<-dnorm(xfit,mean=mean(Petal),sd=sd(Petal)) 		
yfit <- yfit*diff(h$mids[1:2])*length(Petal) 		
lines(xfit, yfit, col="blue", lwd=2)		
```		

## Density plots

```{r}
dens <- density(iris$Petal.Length) 		
plot(dens, main="Kernel Density of Petal Length") 		
polygon(dens, col="pink", border="purple")		
```
* polygon = to color the density plot


We can compare different Kernel density groups with the <b> sm package </b>

```{r}
library(sm)
# create value labels 
spec.f <- factor(Species,
                labels = c("setosa", "versicolor", "virginica")) 
# plot densities 
sm.density.compare(Petal.Length, Species, xlab="Petal Length")
title(main="Petal Length by Specie")
# add legend 
colfill<-c(2:(2+length(levels(spec.f)))) 
legend("topright", levels(spec.f), fill=colfill)
```

# Others

## Box plots
```{r}
boxplot(Petal.Length~Species,data=iris, main="Species Petal Length", 		
        xlab="Species", ylab="Petal Length")
```

By adding varwidth=TRUE to the formula we can make the boxplot widths proportional to the square root of the samples sizes. 			
By adding horizontal=TRUE we reverse the axis orientation.

### Interpreting boxplots 

From Naomi Robbins’ book: Creating More Effective Graphs: “The rectangle shows the interquartile range (IQR); it goes from the first quartile (the 25th percentile) to the third quartile (the 75th percentile). The whiskers go from the minimum value to the maximum value unless the distance from the minimum value to the first quartile is more than 1.5 times the IQR. In that case the whisker extends out to the smallest value within 1.5 times the IQR from the first quartile. A similar rule is used for values larger than 1.5 times IQR from the third quartile. A special symbol shows the values, called outliers, which are smaller or larger than the whiskers.” pg.91


### Notched Boxplot

It is also possible to create a notched Boxplot of a variable against 2 crossed factors.		
This time we used the example of the Carbon Dioxide Uptake in Grass Plants against Type and treatment


```{r}
boxplot(uptake~Type*Treatment, data=CO2, notch=TRUE, 		
        col=(c("gold","darkgreen")),		
        main="Carbon Dioxide Uptake in Grass Plants", xlab="Type and treatment")		
```

### Violin Plot

With a violin plot (<b>vioplot</b> package) we can visualise easily the density data.		

```{r}
iris$Species <- as.numeric(iris$Species) 		
library(vioplot)		
x1 <- iris$Petal.Length[iris$Species==1]		
x2 <- iris$Petal.Length[iris$Species==2]		
x3 <- iris$Petal.Length[iris$Species==3]		
vioplot(x1, x2, x3, names=c("setosa", "versicolor", "virginica"), 		
        col="gold")		
title("Violin Plots of Petal Length")		
```

### Bagplot

Witht the <b>aplpack</b> package we can create a bivariate (2D) boxplot. 50% of the points are in the bag.

```{r}
library(aplpack)			
bagplot(Petal.Length, Sepal.Length, xlab="Petal Length ",ylab="Sepal Length ",			
        main="Iris Bagplot ")		
```     		  




```{r}
detach(iris)
```



# Understanding graphics 


## Colors

http://www.mepheoscience.com/colourful-ecology-part-1-extracting-colours-from-an-image-and-selecting-them-using-community-phylogenetics-theory/




